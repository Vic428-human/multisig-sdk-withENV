<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="./bundle.js"></script>
    <title>webview</title>
</head>

<body>  
    <!-- 發起人初始化 : 不同人點選初始化時傳的私鑰都不同-->
    <button onclick="calledInit(env.APP_TYPE,env.APP_PROVIDER,env.APP_SIGNER,env.APP_SAFE_ADDRESS)">calledInit[初始化]</button>
    <!-- 交易創建 -->
    <button onclick="calledCreateTransaction(env.APP_PROVIDER,env.APP_TYPE,env.APP_PEPE_ADDRESS,env.APP_TRANSFER_AMOUNT,env.APP_TRANSFER_DECIMAL,env.APP_DESTINATION)">calledCreateTransaction[發起人創建+簽名]</button>
    
    <!-- 第二個人初始化 -->
    <button onclick="calledInit(env.APP_TYPE,env.APP_PROVIDER,env.APP_SIGNER_2,env.APP_SAFE_ADDRESS)">calledInit[第二個人初始化]</button>
    <!-- 第二個人簽署 -->
    <button onclick="calledSignTransactionFromMobile(globalInitTxSignedStr,env.APP_TYPE,env.APP_PROVIDER,env.APP_SIGNER_2,env.APP_SAFE_ADDRESS)">calledSignTransactionFromMobile[第二人簽名]</button>

    <script>

        const {
            axios,
            SafeProtocalKit,
            ethers,
            env,
        } = window.utils

        // 全局safe 已經初始化
        let globalSafe;
        let globalSigner;
        let safeTx;
        let globalInitTxSignedStr = 'default';
        let device = "IOS";

      
        /** [utils] 
         * 根據設備類型調用相應的應用程序消息處理程序。
         * 將SDK的內容回傳給 手機端
         * 
         * @function callApp
         * @param {string} string - 要傳遞的消息字符串。
         * @param {string} [type='callMessage'] - 橋樑識別符，默認為 'callMessage'。
         * @throws {Error} 如果設備類型不支持，則拋出錯誤。
         */
        const callApp = (string, type = 'callMessage') => {
            new Map([
                [
                    "IOS",
                    () => {
                        console.log(`====從網頁端傳資料給手機端=====`,string)
                        // 橋樑識別符值 jsToSwift
                        //window.webkit.messageHandlers.<橋樑識別符值>.postMessage
                        // TODO: 開始對接前取消註解
                        // window?.webkit.messageHandlers[type].postMessage(string);
                    },
                ],
                [
                    "Android",
                    () => {
                        JsAndroid[type](string);
                    },
                ],
            ]).get(device)();
        };


        /** [按鈕] 初始化 0x5 發起人 進入手機介面當下就進行初始化
         * @async
         * @function 
         * @param {string} type - 調用類型。 橋樑識別符值
         * @param {string} provider - 根據不同鏈路帶入對應的RPC URL。
         * @param {string} signer - 私鑰。 發起人用的簽名私鑰
         * @param {string} safeAddress - 多簽錢包合約地址。
         * 
         * @returns {Promise<void>} - 無返回值。
         * @throws {Error} - 如果初始化失敗，將拋出錯誤並調用 callApp 函數。
         */
        const calledInit = async (type, provider, signer, safeAddress) => {
            try {     
                console.log("signer===>",signer)         
                globalSigner = signer;
                console.log("globalSigner signer===>",globalSigner)   
                globalSafe =  await SafeProtocalKit.default.init({
                    provider, //根據不同鏈路帶入對應的RPC URL
                    signer, // 私鑰
                    safeAddress, // 多簽錢包合約地址
                });
                console.log('初始化SAFE SDK==>',globalSafe)
                let initGlobalSafe = await stringifyObjectWithFunctions(globalSafe);
                // 初始化完之後告訴手機端已經初始化，但因為網頁沒有關掉，手機只是待機狀態，
                // 等待別人簽名，目前全局globalSafe仍然已經是初始化狀態，
                // 所以待會可以直接呼叫
                callApp(initGlobalSafe, type);
                console.log("手機端已經收到初始化資訊")
                return initGlobalSafe;
            } catch (error) {
                callApp(error, 'error');
            }
        };
        

        /** [按鈕] 0x5 發起人 發起創建交易時 同時 開始進行簽名投票
         * @async
         * @function createTransaction
         * @param {string} provider - 根據不同鏈路帶入對應的RPC URL。
         * @param {string} type - 調用類型。 橋樑識別符值
         * @param {string} pepeAddress - EVM的山寨幣合約地址。
         * @param {string} transferAmount - 轉出的數量
         * @param {string} transferDecimal - 當前Token的位數。
         * @param {string} destination - 轉到哪一個外部錢包
         * @returns {Promise<void>} - 無返回值。
         * @throws {Error} - 如果初始化失敗，將拋出錯誤並調用 callApp 函數。
         */
        const calledCreateTransaction = async (provider, type, pepeAddress, transferAmount,transferDecimal,destination) => {
            try {
                console.log('發起人簽名： type ==>', type)
                const erc20Abi = [
                    "function transfer(address to, uint amount) returns (bool)",
                    "function balanceOf(address account) view returns (uint256)",
                ];
                const erc20Contract = new ethers.Contract(pepeAddress, erc20Abi, provider);
                const amount = ethers.parseUnits(transferAmount, Number(transferDecimal));
                console.log('發起人簽名： amount ==>', typeof amount)

                const encodedTransferData = encodeTransferData(erc20Contract, destination, amount);
                const batchTxs = { to: pepeAddress, value: '0', data: encodedTransferData };
                // 複製 [發起人剛才創建交易] 的交易內容
                safeTx =  await globalSafe.createTransaction({ transactions: [batchTxs] });
                // 發起人簽名
                let ownerVoterSign = await signTransaction(globalSafe,safeTx);
                // 序列化
                let initTxSignedStr = await serializeData(ownerVoterSign);
                console.log('發起人簽名： initTxSignedStr ==>', initTxSignedStr)
                
                globalInitTxSignedStr = initTxSignedStr;
                console.log('發起人簽名： globalInitTxSignedStr ==>', globalInitTxSignedStr)
                // 這邊要加上從js呼叫手機端的代碼，此時發起人手機已經收到自己簽名的紀錄
                // 手機端會另外存給後端
                callApp(globalInitTxSignedStr, type);
            } catch (error) {
                console.log('error==>',error)
                callApp(error, 'error');
            }
        };

         /** [按鈕] 其餘簽署人開始簽名投票
         * @async
         * @function calledSignTransactionFromMobile 
         * @param {string} globalInitTxSignedStr - 先拿上一次簽署紀錄。
         * @returns {Promise<void>} - 無返回值。
         * @throws {Error} - 如果初始化失敗，將拋出錯誤並調用 callApp 函數。
         */
        const calledSignTransactionFromMobile = async (globalInitTxSignedStr,type, provider,signer, safeAddress) => {
            console.log("======準備開始進行第二個人簽署=======")
            try{
                if(globalInitTxSignedStr === 'default'){
                    console.log("default")
                    return;
                }
                console.log(`格式：${typeof globalInitTxSignedStr} 先拿上一次簽署紀錄`,globalInitTxSignedStr)
                let convertedToJson = await deserializeData(globalInitTxSignedStr)
                console.log(`格式：${typeof convertedToJson} [反序列化]先拿上一次簽署紀錄`,convertedToJson)
                let sndMutiSigAndVote = await signTransaction(globalSafe,convertedToJson);
                console.log("第二個人已經簽名====>",sndMutiSigAndVote);

            }catch (error) {
                console.log('error==>',error)
                callApp(error, 'error');
            }
        }
        
        /** [utils]
         * @async
         * @function signTransaction 
         * @param {string} globalSafe - 當前手機的持有者的私鑰簽署初始化實例
         * @param {string} payload - 先前人的簽署 payload 或 發起者的創建交易
         * @param {string} signingMethod - 簽名方法。 [目前文檔上有看到三種]
         * @returns {Promise<SafeTransaction>} -SAFE SDK 關於 signTransaction 的物件
         */
         async function signTransaction(globalSafe, payload, signingMethod = SafeProtocalKit.SigningMethod.ETH_SIGN_TYPED_DATA_V4){
            return globalSafe.signTransaction(payload, signingMethod)
        }

        /** [utils]
         * 編碼 ERC20 代幣轉帳所需的數據。
         * @function encodeTransferData 
         * @param {Contract} erc20Contract - ERC20 合約實例，用於與代幣進行交互。
         * @param {string} destination - 接收代幣的目標錢包地址。
         * @param {bigint} amount - 要轉帳的代幣數量。
         * @returns {string} - 轉帳交易的編碼數據。
         */
        function encodeTransferData(erc20Contract, destination, amount) {
            return erc20Contract.interface.encodeFunctionData("transfer", [destination, amount]);
        }


        function serializeData(data) {
            return JSON.stringify(data, (key, value) => {
                if (value instanceof Map) {
                    return { dataType: 'Map', value: Array.from(value.entries()) };
                }
                if (value instanceof Set) {
                    return { dataType: 'Set', value: Array.from(value) };
                }
            return value;
            });
        }
        
        function deserializeData(dataString) {
            if (!dataString) return null;
        
            return JSON.parse(dataString, (key, value) => {
            if (value?.dataType === 'Map') {
                return new Map(value.value);
            }
            if (value?.dataType === 'Set') {
                return new Set(value.value);
            }
            return value;
            });
        }
        /**
         * Converts an object to a JSON string, including functions as their string representations.
         *
         * @param {Object} obj - The object to be stringified.
         * @returns {string} - The JSON string representation of the object, with functions converted to strings.
         */
        function stringifyObjectWithFunctions(obj) {
            const objCopy = Object.assign({}, obj);
            for (const key in objCopy) {
                if (typeof objCopy[key] === "function") {
                    objCopy[key] = objCopy[key].toString();
                }
            }
            return JSON.stringify(objCopy);
        }

    </script>
</body>

</html>