<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="./bundle.js"></script>
    <!-- <link rel="stylesheet" href="./index.css"> -->
    <title>webview</title>
</head>

<body>
    <button id="init-button">calledInit[初始化]</button>
    <button class="primary" id="create-transaction-button">
        calledCreateTransaction[創建交易]
    </button>
    <button class="primary" id="sign-transaction-button">發起人簽名</button>

    <button id="init-button2">calledInit[第二個人初始化]</button>
    <button class="danger" id="sign-transaction-button2">
        calledSignTransactionFromMobile[第二人簽名]
    </button>

    <button id="execute-transaction-button" class="danger">發起人上鏈</button>
    <script>
        const {
            axios,
            SafeProtocalKit,
            ethers,
            env,
        } = window.utils

        //從app告訴我們設備類型
        let device = "IOS";
        //初始化後設置全局變數
        let globalSafe;

        //紀錄發起人的簽名私鑰
        let globalProvider;
        let globalSigner;

        //模擬手機傳入的紀錄,web端紀錄起來使用
        let prevState

        /** [utils] 
         * @function tellMeDevice
         * @param {string} type - 橋樑識別符
         * @param {string} appDevice 設備類型
         * @throws {Error} 如果設備類型不支持，則拋出錯誤。
         */
        const tellMeDevice = (type, appDevice) => {
            device = appDevice

            try {
                device = appDevice
                callApp(device, type);
            } catch (error) {
                callApp(error, 'error');
            }
        }


        /** [utils] 
         * 根據設備類型調用相應的應用程序消息處理程序。
         * 將SDK的內容回傳給 手機端
         * 
         * @function callApp
         * @param {string} string - 要傳遞的消息字符串。
         * @param {string} [type='callMessage'] - 橋樑識別符，默認為 'callMessage'。
         * @throws {Error} 如果設備類型不支持，則拋出錯誤。
         */
        const callApp = (string, type = 'callMessage') => {
            new Map([
                [
                    "IOS",
                    () => {
                        console.log(type, stringifyObjectWithFunctions(string))
                        // 橋樑識別符值 jsToSwift
                        //window.webkit.messageHandlers.<橋樑識別符值>.postMessage
                        window?.webkit.messageHandlers[type].postMessage(stringifyObjectWithFunctions(string));
                    },
                ],
                [
                    "Android",
                    () => {
                        JsAndroid[type](stringifyObjectWithFunctions(string));
                    },
                ],
            ]).get(device)();
        };


        /** [按鈕] 初始化 進入手機介面當下就進行初始化
         * @async
         * @function calledInit
         * @param {string} type - 調用類型。 橋樑識別符值
         * @param {string} provider - 根據不同鏈路帶入對應的RPC URL。
         * @param {string} signer - 私鑰。 當前使用者的簽名私鑰
         * @param {string} safeAddress - 多簽錢包合約地址。
         * 
         * @returns {Promise<void>} - 無返回值。
         * @throws {Error} - 如果初始化失敗，將拋出錯誤並調用 callApp 函數。
         */
        const calledInit = async (type, provider, signer, safeAddress) => {
            try {
                globalSigner = signer;
                globalProvider = provider;
                globalSafe = await SafeProtocalKit.default.init({
                    provider, //根據不同鏈路帶入對應的RPC URL
                    signer, // 私鑰
                    safeAddress, // 多簽錢包合約地址
                });
                let initGlobalSafe = await stringifyObjectWithFunctions(globalSafe);
                callApp(initGlobalSafe, type);
                return initGlobalSafe;
            } catch (error) {
                callApp(error, 'error');
            }
        };


        /** [按鈕] 創建交易
         * 任何 owner [signer] 都可能成為發起者，所以當Owner中，有一方成為發起者，其他Owner包含發起者本人，都要經歷簽署環節，至於幾個人簽名取決於當時的threshold。
         * @async
         * @function calledCreateTransaction
         * @param {string} type - 調用類型。 橋樑識別符值
         * @param {string} provider - 根據不同鏈路帶入對應的RPC URL。
         * @param {string} pepeAddress - EVM的山寨幣合約地址。
         * @param {string} transferAmount - 轉出的數量
         * @param {string} transferDecimal - 多簽錢包合約地址。
         * @param {string} destination - 轉到哪一個外部錢包
         * @param {string} nonce - 隨機數，可以由UI介面客製化自己定義
         * @returns {Promise<void>} - 無返回值。
         * @throws {Error} - 如果初始化失敗，將拋出錯誤並調用 callApp 函數。
         */
        const calledCreateTransaction = async (type, provider, tokenAddress, transferAmount, transferDecimal, destination, nonce) => {
            try {
                console.log('當前幣種==>',tokenAddress)
                console.log('當前幣種位數==>',transferDecimal)

                const erc20Abi = [
                    "function transfer(address to, uint amount) returns (bool)",
                    "function balanceOf(address account) view returns (uint256)",
                ];
                const erc20Contract = new ethers.Contract(tokenAddress, erc20Abi, provider);
                const amount = ethers.parseUnits(transferAmount, Number(transferDecimal));

                const encodedTransferData = erc20Contract.interface.encodeFunctionData("transfer", [destination, amount]);


                // 設置交易對象：根據是否為 native token 或 ERC20 token 決定參數
                const transaction = tokenAddress.startsWith("0x00")
                    ? {
                        to: destination,
                        value: amount,
                        data: '0x00'
                    } // native token
                    : {
                        to: tokenAddress,
                        value: '0',
                        data: encodedTransferData
                    }; // ERC20 token

                // 設置選項對象：如果 nonce 是 'false'，設為 undefined
                const options = {
                    nonce: nonce !== 'false' ? nonce : undefined
                };

                const createTransactionResult = await globalSafe.createTransaction({
                    transactions: [transaction],
                    options
                });

                const result = {
                    data: createTransactionResult.data,
                    signatures: mapToObject(createTransactionResult.signatures)
                }
                prevState = JSON.stringify(result)
                callApp(result, type);
            } catch (error) {
                callApp(error, 'error');
            }
        };


        /** [按鈕] 簽名投票
         * @async
         * @function calledSignTransactionFromMobile 
         * @param {string} type - 調用類型。 橋樑識別符值
         * @param {string} prevSignStr - 先前的簽署紀錄
         * @returns {Promise<void>} - 無返回值。
         * @throws {Error} - 如果初始化失敗，將拋出錯誤並調用 callApp 函數。
         */
        const calledSignTransactionFromMobile = async (type, prevSignStr) => {
            const prevSign = JSON.parse(prevSignStr)
            try {
                const signResult = await globalSafe.signTransaction({
                    data: prevSign.data,
                    signatures: objectToMap(prevSign.signatures)
                }, SafeProtocalKit.SigningMethod.ETH_SIGN_TYPED_DATA_V4)
                const result = {
                    data: signResult.data,
                    signatures: mapToObject(signResult.signatures)
                }
                prevState = JSON.stringify(result)
                callApp(result, type);
            } catch (error) {
                callApp(error, 'error');
            }
        }

         /** [按鈕] 發起者上鏈 (假設threshold已經達標)
         * @async
         * @function calledExecuteTransaction 
         * @param {string} type - 調用類型。 橋樑識別符值
         * @param {string} prevSignStr - 先前的簽署紀錄
         * @returns {Promise<void>} - 無返回值。
         * @throws {Error} - 如果初始化失敗，將拋出錯誤並調用 callApp 函數。
         */
        const calledExecuteTransaction = async (type, prevSignStr) => {
            const prevSign = JSON.parse(prevSignStr)
            try {
                const executeResult = await globalSafe.executeTransaction({
                    data: prevSign.data,
                    signatures: objectToMap(prevSign.signatures)
                });
                const result = {
                    ...executeResult,
                    transactionResponse: stringifyObjectWithFunctions(executeResult.transactionResponse)
                }
                callApp(result, type);
            } catch (error) {
                callApp(error, 'error');
            }
        };


        function stringifyObjectWithFunctions(obj) {
            if (obj === null || typeof obj !== 'object') {
                return String(obj);
            }

            const objCopy = Object.assign({}, obj);
            for (const key in objCopy) {
                if (typeof objCopy[key] === "function") {
                    objCopy[key] = objCopy[key].toString();
                }
            }
            return JSON.stringify(objCopy);
        }

        function mapToObject(map) {
            const obj = {};
            map.forEach((value, key) => {
                obj[key] = value;
            });
            return obj;
        }

        function objectToMap(obj) {
            const map = new Map();
            Object.entries(obj).forEach(([key, value]) => {
                map.set(key, value);
            });
            return map;
        }

        document.getElementById('init-button').addEventListener('click', () => {
            calledInit(env.APP_TYPE, env.APP_PROVIDER, env.APP_SIGNER, env.APP_SAFE_ADDRESS);
        });

        document.getElementById('create-transaction-button').addEventListener('click', () => {
            calledCreateTransaction(env.APP_TYPE, env.APP_PROVIDER, env.APP_USDT_ADDRESS, env.APP_TRANSFER_AMOUNT, env.APP_TRANSFER_DECIMAL, env.APP_DESTINATION, env.APP_NONCE);
        });

        document.getElementById('sign-transaction-button').addEventListener('click', () => {
            calledSignTransactionFromMobile('', prevState);
        });

        document.getElementById('init-button2').addEventListener('click', () => {
            calledInit(env.APP_TYPE, env.APP_PROVIDER, env.APP_SIGNER_2, env.APP_SAFE_ADDRESS);
        });

        document.getElementById('sign-transaction-button2').addEventListener('click', () => {
            calledSignTransactionFromMobile('', prevState);
        });

        document.getElementById('execute-transaction-button').addEventListener('click', async () => {
            await globalSafe.connect({ provider: globalProvider, signer: globalSigner })
            calledExecuteTransaction('execute', prevState);
        });

    </script>
</body>

</html>